import { Router } from "express";
import { createDAVClient, fetchCalendars, fetchCalendarObjects, createAccount } from "tsdav";
import rrulePkg from "rrule";
import { requireAuth } from "../middleware/auth";
import { CalendarConfigModel } from "../models/CalendarConfig";
import { getAuthorizedClient } from "./google";
import { google } from "googleapis";
import { connect as connectMongo } from "../mongo";

const { rrulestr } = rrulePkg;
const eventCache: Record<string, any[]> = {};

function createCacheKey(...args: string[]): string {
  return args.join(":");
}

function getCachedEvents(key: string): any[] | null {
  return eventCache[key] || null;
}

function setCachedEvents(key: string, events: any[]): void {
  eventCache[key] = events;
}

function requireAdmin(req: any, res: any, next: any) {
  if (req.user?.role !== "admin") {
    return res.status(403).json({ error: "forbidden" });
  }
  next();
}

function getIcloudCreds() {
  return {
    username: process.env.APPLE_ID || "",
    password: process.env.APPLE_APP_PASSWORD || "",
  };
}

function parseICalDate(val: string): Date {
  if (val.match(/^[0-9]{8}$/)) {
    return new Date(`${val.slice(0,4)}-${val.slice(4,6)}-${val.slice(6,8)}`);
  }
  if (val.match(/^[0-9]{8}T[0-9]{6}Z?$/)) {
    return new Date(`${val.slice(0,4)}-${val.slice(4,6)}-${val.slice(6,8)}T${val.slice(9,11)}:${val.slice(11,13)}:${val.slice(13,15)}${val.endsWith('Z') ? 'Z' : ''}`);
  }
  return new Date(val);
}

function parseICalEvents(objects: any[], from: Date, to: Date) {
  return events;
}

// Function to fetch calendar display names via PROPFIND
async function fetchCalendarDisplayNames(calendarUrls: string[], credentials: { username: string; password: string }): Promise<Record<string, string>> {
  const names: Record<string, string> = {};
  for (let i = 0; i < calendarUrls.length; i++) {
    const url = calendarUrls[i];
    try {
      const propfindBody = `<?xml version="1.0" encoding="UTF-8"?>
<d:propfind xmlns:d="DAV:" xmlns:c="urn:ietf:params:xml:ns:caldav">
  <d:prop><d:displayname/></d:prop>
</d:propfind>`;
      const res = await fetch(url, {
        method: 'PROPFIND',
        headers: {
          Authorization: `Basic ${Buffer.from(`${credentials.username}:${credentials.password}`).toString('base64')}`,
          'Content-Type': 'application/xml',
          Depth: '0',
        },
        body: propfindBody,
      });
      if (res.ok) {
        const xml = await res.text();
        const m = xml.match(/<d:displayname[^>]*>([^<]*)<\/d:displayname>/i);
        names[url] = m?.[1].trim() || `Calendar ${i + 1}`;
      } else {
        names[url] = `Calendar ${i + 1}`;
      }
    } catch (e) {
      console.error('[iCloud] fetchCalendarDisplayNames error', e);
      names[url] = `Calendar ${i + 1}`;
    }
  }
  return names;
}

const router = Router();
        method: 'PROPFIND',
        headers: {
          'Authorization': `Basic ${Buffer.from(`${credentials.username}:${credentials.password}`).toString('base64')}`,
          'Content-Type': 'application/xml',
          'Depth': '0'
        },
        body: propfindBody
      });

      if (response.ok) {
        const xmlText = await response.text();
        const match = xmlText.match(/<d:displayname[^>]*>([^<]*)<\/d:displayname>/i);
        names[calendarUrl] = match?.[1].trim() || `Calendar ${i + 1}`;
      } else {
        names[calendarUrl] = `Calendar ${i + 1}`;
      }
    } catch (error) {
      console.error(`[iCloud] fetchCalendarDisplayNames error for ${calendarUrl}:`, error);
      names[calendarUrl] = `Calendar ${i + 1}`;
    }
  }
  return names;
}

function requireAdmin(req: any, res: any, next: any) {
  if (req.user?.role !== "admin") {
    return res.status(403).json({ error: "forbidden" });
  }
  next();
}

function getIcloudCreds() {
  return {
    username: process.env.APPLE_ID || "",
    password: process.env.APPLE_APP_PASSWORD || "",
  };
}

function parseICalDate(val: string): Date {
  if (val.match(/^[0-9]{8}$/)) {
    return new Date(`${val.slice(0,4)}-${val.slice(4,6)}-${val.slice(6,8)}`);
  }
  if (val.match(/^[0-9]{8}T[0-9]{6}Z?$/)) {
    return new Date(`${val.slice(0,4)}-${val.slice(4,6)}-${val.slice(6,8)}T${val.slice(9,11)}:${val.slice(11,13)}:${val.slice(13,15)}${val.endsWith('Z') ? 'Z' : ''}`);
  }
  return new Date(val);
}

function parseICalEvents(objects: any[], from: Date, to: Date) {
  const events = [];
  
  for (const obj of objects) {
    if (!obj?.data || !obj.data.includes('BEGIN:VEVENT')) continue;
    
    const dtstart = obj.data.match(/DTSTART[^:]*:(.+)/);
    const dtend = obj.data.match(/DTEND[^:]*:(.+)/);
    const uid = obj.data.match(/UID:(.+)/)?.[1]?.split('\n')[0].trim() || 'unknown';
    const summary = obj.data.match(/SUMMARY:(.+)/)?.[1]?.split('\n')[0].trim() || '';
    
    if (!dtstart) continue;
    
    const startDate = parseICalDate(dtstart[1].trim());
    const endDate = dtend ? parseICalDate(dtend[1].trim()) : startDate;
    
    if (isNaN(startDate.getTime()) || startDate > to || endDate < from) continue;
    
    events.push({
      uid,
      summary,
      start: startDate.toISOString(),
      end: endDate.toISOString(),
      isRecurring: false,
      raw: obj.data
    });
  }
  
  return events;
}

const router = Router();

// Apply authentication to all routes
router.use(requireAuth);

// GET /api/icloud/config - Return calendar configuration
// GET /api/icloud/config - Return unified calendar configuration for iCloud & Google
router.get("/config", requireAdmin, async (req, res) => {
  console.log('[iCloud] GET /config endpoint hit');
  try {
    // Ensure DB connection
    await connectMongo();
    // Load stored settings
    const configDoc: any = await CalendarConfigModel.findOne() || new CalendarConfigModel();
    const busySet = new Set(configDoc.busyCalendars || []);
    const displayNames: Record<string,string> = configDoc.calendarDisplayNames || {};
    const colors: Record<string,string> = configDoc.calendarColors || {};
    // Collect calendar infos
    const infos: Array<{ displayName: string; url: string; busy: boolean; color: string }> = [];
    // iCloud calendars
    try {
      const creds = getIcloudCreds();
      if (creds.username && creds.password) {
        const davClient = await createDAVClient({ serverUrl: "https://caldav.icloud.com", credentials: creds, authMethod: "Basic", defaultAccountType: "caldav" });
        const account = {
          ...davClient,
          accountType: "caldav" as const,
          serverUrl: "https://caldav.icloud.com",
          homeUrl: `https://caldav.icloud.com/${encodeURIComponent(creds.username)}/calendars/`,
          rootUrl: "https://caldav.icloud.com/"
        };
  // Discover calendars via tsdav
  let icals: any[] = [];
        try {
          icals = await fetchCalendars({ account });
        } catch (e) {
          console.error('[iCloud] fetchCalendars error:', e);
        }
        // Fallback to stored busyCalendars if none discovered
        if (!icals.length && configDoc.busyCalendars?.length) {
          icals = configDoc.busyCalendars.map((url: string) => ({ url }));
        }
        // Fetch real display names
        const icloudNames = await fetchCalendarDisplayNames(icals.map(c => c.url), creds);
        icals.forEach(cal => {
          const url = cal.url;
          const name = displayNames[url] || icloudNames[url] || cal.displayName || url.split('/').filter(Boolean).pop() || url;
          infos.push({
            displayName: name,
            url,
            busy: busySet.has(url),
            color: colors[url] || cal.color || '#007AFF'
          });
        });
      }
    } catch (e) {
      console.error('[iCloud] iCloud calendars error:', e);
    }
    // Google calendars
    try {
      const gClient = await getAuthorizedClient((req as any).user.id);
      if (gClient) {
        const gapi = google.calendar({ version: 'v3', auth: gClient });
        const list = await gapi.calendarList.list({ maxResults: 250 });
        (list.data.items || []).forEach((c: any) => {
          const url = `google://${c.id}`;
          infos.push({
            displayName: displayNames[url] || c.summary || '',
            url,
            busy: busySet.has(url),
            color: colors[url] || (c.backgroundColor || '#007AFF')
          });
        });
      }
    } catch (e) {
      console.error('[iCloud] google calendarList error:', e);
    }
    // Dedupe by URL
    const map = new Map<string, any>();
    infos.forEach(item => map.set(item.url, item));
    const calendars = Array.from(map.values());
    return res.json({
      calendars,
      whitelist: configDoc.whitelistUIDs || [],
      busyEvents: configDoc.busyEventUIDs || [],
      colors
    });
  } catch (error) {
    console.error('[iCloud] GET /config error:', error);
    return res.status(500).json({ error: 'Failed to load calendar configuration' });
  }
});

// GET /api/icloud/status - Check iCloud connection status
router.get("/status", requireAdmin, async (req, res) => {
  try {
    const creds = getIcloudCreds();
    
    if (!creds.username || !creds.password) {
      return res.json({
        connected: false,
        error: "Missing credentials",
        hasUsername: !!creds.username,
        hasPassword: !!creds.password
      });
    }

    // Try a quick connection test
    const client = await createDAVClient({
      serverUrl: "https://caldav.icloud.com",
      credentials: creds,
      authMethod: "Basic",
      defaultAccountType: "caldav",
    });

    const account = {
      ...client,
      accountType: "caldav" as const,
      serverUrl: "https://caldav.icloud.com",
      homeUrl: `https://caldav.icloud.com/${encodeURIComponent(creds.username)}/calendars/`,
      rootUrl: "https://caldav.icloud.com/"
    };

    const calendars = await fetchCalendars({ account });

    res.json({
      connected: true,
      calendarsFound: calendars.length,
      calendars: calendars.map(cal => ({ name: cal.displayName, url: cal.url }))
    });

  } catch (error) {
    console.error('[iCloud] Status check error:', error);
    res.json({
      connected: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

router.get("/week", requireAdmin, async (req, res) => {
  const { start, end } = req.query;
  if (!start || !end) {
    return res.status(400).json({ error: "start_and_end_required" });
  }

  const from = new Date(start as string);
  const to = new Date(end as string);
  const cacheKey = createCacheKey("icloud", "week", start as string, end as string);
  
  const cached = getCachedEvents(cacheKey);
  if (cached) {
    res.json({ events: cached, cached: true });
    fetchAndCacheEvents(from, to, cacheKey).catch(() => {});
    return;
  }

  const events = await fetchAndCacheEvents(from, to, cacheKey);
  res.json({ events, cached: false });
});

router.get("/day", requireAdmin, async (req, res) => {
  const { date } = req.query;
  if (!date) {
    return res.status(400).json({ error: "date_required" });
  }

  const from = new Date(date as string);
  const to = new Date(from.getTime() + 86400000);
  const cacheKey = createCacheKey("icloud", "day", date as string);
  
  const cached = getCachedEvents(cacheKey);
  if (cached) {
    res.json({ events: cached, cached: true });
    fetchAndCacheEvents(from, to, cacheKey).catch(() => {});
    return;
  }

  const events = await fetchAndCacheEvents(from, to, cacheKey);
  res.json({ events, cached: false });
});

router.get("/month", requireAdmin, async (req, res) => {
  const { year, month } = req.query;
  if (!year || !month) {
    return res.status(400).json({ error: "year_and_month_required" });
  }

  const from = new Date(Date.UTC(Number(year), Number(month) - 1, 1));
  const to = new Date(Date.UTC(Number(year), Number(month), 1));
  const cacheKey = createCacheKey("icloud", "month", year as string, month as string);
  
  const cached = getCachedEvents(cacheKey);
  if (cached) {
    res.json({ events: cached, cached: true });
    fetchAndCacheEvents(from, to, cacheKey).catch(() => {});
    return;
  }

  const events = await fetchAndCacheEvents(from, to, cacheKey);
  res.json({ events, cached: false });
});

router.get("/all", requireAdmin, async (req, res) => {
  const from = new Date();
  const to = new Date(Date.now() + 90 * 86400000);
  const cacheKey = createCacheKey("icloud", "all", from.toISOString(), to.toISOString());
  
  const cached = getCachedEvents(cacheKey);
  if (cached) {
    res.json({ events: cached, cached: true });
    fetchAndCacheEvents(from, to, cacheKey).catch(() => {});
    return;
  }

  const events = await fetchAndCacheEvents(from, to, cacheKey);
  res.json({ events, cached: false });
});

export { router };
